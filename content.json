{"meta":{"title":"Diwen's Coding Blog","subtitle":"Coding, Thinking, Blogging","description":null,"author":null,"url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-25T00:25:17.000Z","updated":"2018-05-27T07:07:56.532Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"说点什么Emmmmm… 我花了不少的时间折腾github page和hexo以及这个看上去不错的主题。然后发现不知道该说什么？ 我正在把所有的关于Coding的东西放到Github上面，这绝对是一个麻烦的工作，但看上去却能提高一些学习上的效率。 我的工作绝大部分时间都在Coding，忙碌地完成策划提来的需求，经常需要加班到很晚。所以我还可能写一些吐槽的东西。 学习笔记C++ Primer 5th"}],"posts":[{"title":"关于控制变量的思考","slug":"关于控制变量的思考","date":"2018-06-13T15:04:59.000Z","updated":"2018-06-13T15:35:36.129Z","comments":true,"path":"2018/06/13/关于控制变量的思考/","link":"","permalink":"http://yoursite.com/2018/06/13/关于控制变量的思考/","excerpt":"","text":"在编写业务逻辑时候，经常会使用一些控制变量来控制一些逻辑。比如控制怪物刷新可能需要一个刷新时间戳。 控制变量需要设计得很精简，才不至于出现问题，才不至于在出现问题时候定位困难。通常情况下，控制变量会有这样的流程： 设置值 -&gt; 判断触发 -&gt; 重置值 一个简单的例子： 12345678910111213141516class SomeEvent&#123;public: Update() &#123; // 判断触发 if (m_is_first) &#123; m_is_first = false; // 重置值 // do something for first time ... &#125; &#125;private: bool m_is_first = true; // 设置值，是否是第一次Update&#125;; 但是，又由于它实在是太简单了，用一个unsigned int或者bool就可以表示，以至于在使用的时候过于随意，甚至写出无用的代码。虽然说无用，但无形中可能会增加排错的成本和修改逻辑的成本。 上面的例子还是过于简单，问题不是很明显。一旦一个控制变量的“用户”多了起来，就会感觉十分棘手。这里的用户即是函数。个人感觉，判断触发和重置值应该写在一起，并且只有一处使用。然后通过设置值来进行控制。 在做判断触发的时候，尽量把控制变量委托给定义为const的临时变量，尽量不要与外界的其他逻辑杂糅。因此可能还需要再制造一个Reset方法，并保证只有在触发的时候Reset。感觉这样的流程才清晰很多。再用简单的代码给一个例子： 123456789101112131415161718192021222324252627282930313233343536class MonsterFlush&#123;pubclic: MonsterFlush() : m_next_flush_time(0) &#123; auto next_flush_time = this-&gt;CalcNextFlushTime(); if (next_flush_time &gt; 0) m_next_flush_time = next_flush_time; &#125; void ResetNextFlushTime() &#123; m_next_flush_time = 0 &#125; unsigned int CalcNextFlushTime() &#123; /* ... */ &#125; void Update(unsigned int now_time) &#123; if (m_next_flush_time &gt; 0 &amp;&amp; now_time &gt;= m_next_flush_time) &#123; // flush monster this-&gt;ResetNextFlushTime(); // 只要只有一个地方Reset控制变量，就能放心锁定刷新逻辑的位置 auto next_flush_time = this-&gt;CalcNextFlushTime(); if (next_flush_time &gt; 0) m_next_flush_time = next_flush_time; &#125; &#125; void OnGMFlushNow() &#123; m_next_flush_time = (unsigned int)time(0); &#125;private: unsigned int m_next_flush_time = 0;&#125;;","categories":[],"tags":[]},{"title":"使用ssh公钥登陆Linux","slug":"使用ssh公钥登陆Linux","date":"2018-06-12T14:17:11.000Z","updated":"2018-06-12T14:29:03.016Z","comments":true,"path":"2018/06/12/使用ssh公钥登陆Linux/","link":"","permalink":"http://yoursite.com/2018/06/12/使用ssh公钥登陆Linux/","excerpt":"","text":"使用ssh登陆Linux系统有两种方式： 使用密码 使用公钥认证，双方各持公钥，客户机还会持有私钥 相对于使用密码，公钥认证的方式更加安全。 屏蔽密码登陆 修改文件：/etc/ssh/sshd_config 设置字段：PasswordAuthentication no 重启sshd服务： 1$ systemctl restart sshd 生成密钥 1$ ssh-keygen -t rsa 连续敲击三次回车生成密钥至目录：~/.ssh，id_rsa.pub即是要给服务端的公钥，id_rsa是客户机保留的私钥。 如果是windows系统，则可以使用SecureCRT工具生成：工具-&gt;创建公钥，一些关键步骤是： 密钥类型选择RSA 密钥格式选择OpenSSH 可以自定义密钥名 其余保持默认即可。 加入公钥认证 将公钥的内容加入到文件： ~/.ssh/authorized_keys 重启sshd服务。","categories":[],"tags":[]},{"title":"搭建svn服务器","slug":"搭建svn服务器","date":"2018-06-08T18:42:59.000Z","updated":"2018-06-08T18:55:57.420Z","comments":true,"path":"2018/06/08/搭建svn服务器/","link":"","permalink":"http://yoursite.com/2018/06/08/搭建svn服务器/","excerpt":"","text":"搭建环境：CentOS7 CentOS7可能已经默认安装了svn服务器，输入下列命令验证： 1$ svnserve --version 但可能没有安装svn客户端，使用下列命令安装： 12$ yum install svn$ svn --version` 搭建步骤 12345678910111213141516# 创建一个仓库$ mkdir -p /data/repo$ cd /data/repo$ svnadmin create .# 创建一个项目$ cd$ mkdir project$ svn import project file:///data/repo/project -m \"初始化\"$ rm -fr project# 启动svn服务$ svnserve -d -r /data/repo# 拉取项目，如果是从另一台机器拉，则把IP地址改成对外的地址$ svn co svn://127.0.0.1:3690/project 权限设定 进入到仓库目录的conf目录，修改svnserve.conf文件中的一些字段： 1234anon-access = none #禁止其它用户的访问auth-access = writepassword-db = passwdauthz-db = authz 如果要添加一个用户，修改passwd文件。 如果要给用户权限，修改authz文件。 修改passwd和authz目录后，不需要重启服务即可生效。","categories":[],"tags":[]},{"title":"理论、实践与学习困境","slug":"理论、实践与学习困境","date":"2018-06-08T14:39:46.000Z","updated":"2018-06-08T16:04:21.688Z","comments":true,"path":"2018/06/08/理论、实践与学习困境/","link":"","permalink":"http://yoursite.com/2018/06/08/理论、实践与学习困境/","excerpt":"","text":"在看书过程中，总会遇到一种感觉，就是似懂非懂，以至于苦恼的感觉，就像是一种困境。 比如，我在阅读到bind这一块内容的时候，虽然已经明白它的意思、用法，但内心仍然未有通达之感。这或许是因为在实践中，我极少用过bind函数，但这种方法我知道在C++11之前至少是必不可少的一种可以适配谓词的方法（现在已经可以用lambda表达式取代了）。 但是，书中仍然有这样的表述： 对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。 lambda表达式就像是一个一次性用品，它只给一个用户服务（可能是一个算法，也可能是它当前所在的函数）。于是bind函数又有其用武之地了。但，这对于我而言，仍然只是基于理论上的结论，而非实践上的真知。 在学习C++的过程中，这样的困境实在太多了，于是，我尽量倾向于去思考一些有用的话题，扩展理论至实践。 这里拿bind举例，假如现在有这样的类型： 12345class Message&#123;public: void Log(const char *str) &#123; std::cout &lt;&lt; str &lt;&lt; std::endl; &#125;&#125;; 如果我想调用Log，就必须先定义一个Message对象，可能这个工作会经常重复，我想直接一句话就调用Log，并且效果要一致。显然这里要做一个适配。最简单的办法莫过于定义一个宏： 12345#define log(str)\\do&#123;\\Message msg;\\msg.Log(str);\\&#125;while(0)\\ 这个办法如果对比用bind的，那么就显得幼稚的多了： 1auto log = std::bind(std::bind(&amp;Message::Log, std::placeholders::_1, std::placeholders::_2), Message(), std::placeholders::_1); 这个写法给我的感觉就是装逼的多，但它确实能Work，而且省去了每次创建Message对象的开销，看上去bind在这里确实起到了一个简化代码又适配了成员函数的作用，它竟然用一个普通的函数调用代替了一个成员函数的调用。 完整的代码如： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;functional&gt;class Message&#123;public: void Log(const char *str) &#123; std::cout &lt;&lt; str &lt;&lt; std::endl; &#125;&#125;;// Method 1:/*#define log(str)\\do&#123;\\Message msg;\\msg.Log(str);\\&#125;while(0)\\*/// Method 2:auto log = std::bind(std::bind(&amp;Message::Log, std::placeholders::_1, std::placeholders::_2), Message(), std::placeholders::_1);int main()&#123; log(\"Hello\"); return 0;&#125; 简单的解析一下： 内层的bind是：std::bind(&amp;Message::Log, std::placeholders::_1, std::placeholders::_2)，此bind即适配了Message::Log，_1绑定到的是调用对象，_2绑定到的是str。 外层的bind用来绑定一个Message对象，从而适配了内层的bind。 另外，这个案例完全是我自己瞎写的，目的就是为了脱离一丢丢的学习困境，但实际上仍然是脱离不了，或许只有写出有实际意义的代码，才可能让内心获得更通达的感觉。","categories":[],"tags":[]},{"title":"层级式的数据结构","slug":"层级式的数据结构","date":"2018-06-03T03:47:00.000Z","updated":"2018-05-30T23:51:15.190Z","comments":true,"path":"2018/06/02/层级式的数据结构/","link":"","permalink":"http://yoursite.com/2018/06/02/层级式的数据结构/","excerpt":"","text":"从细节来看，数据结构的确是多种多样，以至于想要熟练应用到代码里面都不是很容易。比如，如果让我去实现一个链表，我也需要去翻翻以前的代码，尽可能确保得到一个正确的实现。 但从大的层面来看，以我目前的能力，能看到的是一种层级式的数据结构。这种结构随处可见，比如目录结构，就是一个层级结构。 如果用代码来表示一个层级结构，也不怎么费力： 123456789101112131415161718struct Person&#123; string name; vector&lt;unsigned&gt; phone_num;&#125;;class PersonManager&#123;public: static PersonManager&amp; Instance() &#123; static PersonManager inst; return inst; &#125;private: PersonManager() &#123;&#125; ~PersonManager() &#123;&#125; vector&lt;Person&gt; person_vec;&#125;; 得到这样一种层级关系： PersonManager -&gt; Person -&gt; phone_num, name 用这种方式组织数据很容易管理各种实体对象，尽管在细节的实现上面，可以采用各种数据结构，比如vector，map，但大的层面上，却脱离不了层级关系。 理解一个系统，如果能从大的方面把它的组织结构搞清楚，那么去理解其细节才能更轻松，而大的系统，往往都是有一个层级结构在那里。 希望我的理解是对的。","categories":[],"tags":[]},{"title":"CentOS7升级gcc版本","slug":"CentOS7升级gcc版本","date":"2018-05-27T17:13:52.000Z","updated":"2018-06-08T14:28:06.388Z","comments":true,"path":"2018/05/27/CentOS7升级gcc版本/","link":"","permalink":"http://yoursite.com/2018/05/27/CentOS7升级gcc版本/","excerpt":"","text":"今天学习C++ Primer中的正则表达式部分的时候遇到一个问题，运行书本的程序后，必然会抛出regex_error的异常，在stackoverflow上面看到这是因为编译器版本的问题，我当前的gcc版本是4.8.5，还没能全部支持正则表达式库，需要升级到4.9.2。 升级的方法是从GNU官网上面下载相应的源码，然后本地编译安装。 步骤如下： 123456789101112131415$ wget http://ftp.gnu.org/gnu/gcc/gcc-4.9.2/gcc-4.9.2.tar.gz$ tar -xvf gcc-4.9.2.tar.gz$ cd gcc-4.9.2$ ./contrib/download_prerequisites # 自动解决依赖$ mkdir build$ cd build$ ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib # 生成Makefile文件$ make -j4 # 编译$ make install$ gcc -v 不过，这种方式还是太过于麻烦，由于网络原因，下载速度堪忧。而且编译也要等待很久。如果中途出现错误，是令人非常沮丧的。我认为像这样的安装，需要有经验的人来指导，才不会陷入苦恼。 更快捷的方法是使用scl来提升gcc版本。scl，即Software Collections，它允许在操作系统上运行不同版本的软件，比如不同版本的gcc。目前，scl的devtoolset-4中的gcc已经达到了5.3版本以上。 安装devtoolset-4的步骤如下： 123456$ yum install centos-release-scl$ yum install devtoolset-4-toolchain# 验证$ scl enable devtoolset-4 bash$ gcc --version 使用yum安装总是令人愉快的。","categories":[],"tags":[]},{"title":"阻塞模式与轮询模式","slug":"阻塞模式与轮询模式","date":"2018-05-27T14:28:39.000Z","updated":"2018-05-27T15:04:30.036Z","comments":true,"path":"2018/05/27/阻塞模式与轮询模式/","link":"","permalink":"http://yoursite.com/2018/05/27/阻塞模式与轮询模式/","excerpt":"","text":"在实际编程中，总会遇到一些相似的情况，比如最简单的Hello World程序，程序完成输出的目的后就结束了，这就可以将其总结为一种编程模式：【运行 -&gt; 输出 -&gt; 返回】，在课本的练习中这种模式很常见。 不过，这种模式的功能实在是有限，比如无法交互，无法处理不确定的事件，这往往是业务中所需要的。比如最简单的计算加法的结果，必须要求用户输入运算数字才能够进行计算： 123456789int main()&#123; int a = 0, b = 0; std::cin &gt;&gt; a &gt;&gt; b; printf(\"%d + %d = %d\\n\", a, b, a + b); return 0;&#125; 可以把它总结为一种阻塞式的编程模式，在这种模式下，程序会阻塞等待某些事件，这些事件往往是操作系统控制的。比如在程序等待输入时，通过键入一串内容，然后敲下回车，程序就会从终端读取数据。 但是阻塞模式会遇到一个问题，那就是在阻塞的时候，程序（或者说这个被阻塞的执行线程）什么都做不了。这个时候可以采用轮询的方法，也就是隔一段时间，执行一次处理： 12345678910void loop()&#123; while (true) &#123; // do one thing // do another thing sleep(1); &#125;&#125; 但是要注意的是，轮询中的处理方式都不能是阻塞的，不然就会影响到其他工作的处理了。 操作系统更喜欢阻塞模式的程序，在Linux系统下，这样的程序会被奖励nice值，从而获得更高的响应速度，而且这样的程序消耗的CPU时间也更少。 但我觉得阻塞模式的程序不太好设计，因为它更多的涉及到操作系统层面，比如从终端读取输入、进程挂起（pause）、线程锁、socket接受连接等，阻塞的来源和处理的方法都不一样。而轮询的模式仅涉及到像sleep（或者usleep）这样的比较简单的函数，在实际编程中看上去更简洁。","categories":[{"name":"C++随笔","slug":"C-随笔","permalink":"http://yoursite.com/categories/C-随笔/"}],"tags":[]},{"title":"VirtualBox安装CentOS7及其相关配置","slug":"VirtualBox安装CentOS7及其相关配置","date":"2018-05-27T09:22:10.000Z","updated":"2018-05-27T09:29:43.767Z","comments":true,"path":"2018/05/27/VirtualBox安装CentOS7及其相关配置/","link":"","permalink":"http://yoursite.com/2018/05/27/VirtualBox安装CentOS7及其相关配置/","excerpt":"","text":"安装准备 VirtualBox我是在电脑管家应用中心下载的，是一个免费的虚拟机软件 CentOS 7的镜像我是在CentOS官方网站下载的，DVD ISO版本，也可以直接在这里找：下载地址 VirtualBox安装默认步骤就可以安装了。 CentOS 7安装 打开VirtualBox，点击新建（ctrl + n） 填写如下配置： 接下来是配置设置，保持默认选项就可以了，创建成功。 点击启动，首次启动会选择一个启动盘，选择CentOS 7的镜像文件启动 选择Install CentOS后就进入到图形界面安装了，根据提示来Continue就可以了，只有一步需要注意，就是安装Software Selection不要保持默认，选择Infrastructure Server，把右边的选项都勾起来，如下： 然后等待安装成功就可以了。这是一个无图形界面的版本。 相关配置网络设置目标是通过SecureCRT来连接虚拟机，步骤是： 用root登陆后，输入dhclient，获取一个虚拟机IP 右键虚拟机，选择设置（ctrl + s） –&gt; 网络，连接方式选择网络地址转换（NAT），高级 –&gt; 端口转发，添加一个端口转发，主机IP是本机IP，端口号自定义，但要记住，以后SecureCRT连的就是这个IP和端口；子系统IP是虚拟机IP，端口是22，如图： 这里是说明，连接本机的192.168.11.214:9988，就相当于连接虚拟机的10.0.2.15:22 然后使用SecureCRT连接就可以了，但这里有一个问题，每次重启都要输入dhclient来分配一个ip，解决方法是： 编辑文件vim /etc/sysconfig/network-scripts/ifcfg-enp0s3，将NOBOOT的值改成yes。（虽然我不清楚为什么，但这样做就可以） 共享本机硬盘目标是共享主机上的某一个目录或磁盘，这样就可以方便的进行开发了（本机开发，虚拟机运行）。步骤是： 点击虚拟机运行窗口 –&gt; 设备 –&gt; 安装增强功能 挂载光盘并安装相关文件： 123mount /dev/cdrom /mediacd /media./VBoxLinuxAdditions.run ctrl + s 打开虚拟机设置 –&gt; 共享文件夹，添加一个本地共享目录，比如是ldw_share，自动挂载，固定分配，如： 在虚拟机里创建一个目录，可以命名为ldw_share，然后输入命令： 12mkdir ldw_sharemount -t vboxsf ldw_share ldw_share # 第一个ldw_share是本机共享目录的共享名（如上），第二个ldw_share是虚拟机的共享目录名 即挂载成功。 修改系统时间默认情况下系统时间不是CST时间（中国上海），输入如下命令设置： 12rm -rf /etc/localtimeln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 修改环境变量PS1PS1代表命令提示符，将其追加到/etc/.bash_profile： 1PS1=\"[\\[\\e[36;1m\\]\\u@\\[\\e[32;1m\\]LDW\\[\\e[31;1m\\] \\t \\[\\e[36;1m\\]\\w\\[\\e[0m\\]]# \" 安装lrzsz工具设置共享目录可以达到本机-虚拟机传送文件的目的，然而我觉得更方便的办法是使用lrzsz工具。 直接输入命令即可安装： 1yum install lrzsz","categories":[],"tags":[]},{"title":"C++显式转换和C语言的强制类型转换之间的区别","slug":"C-显式转换和C语言的强制类型转换之间的区别","date":"2018-05-27T06:25:38.000Z","updated":"2018-05-27T15:06:07.691Z","comments":true,"path":"2018/05/27/C-显式转换和C语言的强制类型转换之间的区别/","link":"","permalink":"http://yoursite.com/2018/05/27/C-显式转换和C语言的强制类型转换之间的区别/","excerpt":"","text":"C语言的强制类型转换的功能更通用，即它具有static_cast, const_cast和reinterpret_cast相似的行为。 关于显式类型转换： static_cast只能应用于明确定义了的类型转换，并且不能用于底层const（lower const）的转换。 const_cast只能改变底层const reinterpret_cast通常用于重新解释一个指针类型，使用需小心。 C语言的强制类型转换没有细分的这么明显，它拥有了这三者的功能。 见代码： 123456789101112131415int a = 0;int *pa = &amp;a; const int *cpa = &amp;a; //static_cast&lt;int*&gt;(cpa); // invalid static_cast from type ‘const int*’ to type ‘int*’//static_cast&lt;char*&gt;(pa); // invalid static_cast from type ‘int*’ to type ‘char*’const_cast&lt;int*&gt;(cpa); // OKreinterpret_cast&lt;char*&gt;(pa);// OK(int*)cpa; // OK(char*)pa; // OKreturn 0;","categories":[{"name":"C++随笔","slug":"C-随笔","permalink":"http://yoursite.com/categories/C-随笔/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Blogging by Hexo","slug":"Blogging-by-Hexo","date":"2018-05-24T20:52:09.000Z","updated":"2018-05-27T06:37:00.148Z","comments":true,"path":"2018/05/24/Blogging-by-Hexo/","link":"","permalink":"http://yoursite.com/2018/05/24/Blogging-by-Hexo/","excerpt":"","text":"环境：CentOS 7 安装Node.js12345$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash$ nvm install stable$ npm install -g hexo-cli 启动Hexo1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install$ hexo server 配置修改_config.yml文件。 写作创建新文章： 1$ hexo new &lt;title&gt; 创建新页面： 1$ hexo new page &lt;page_name&gt; 部署到Github Page安装hexo-deployer-git: 1$ npm install hexo-deployer-git --save 修改配置文件_config.yml: 123deploy: type: git repo: git@github.com:demon90s/demon90s.github.io.git 部署命令： 1$ hexo deploy 选择主题see: https://github.com/iTimeTraveler/hexo-theme-hiker","categories":[],"tags":[]}]}